
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async createQuote(paragraphId: UUIDv7Base64URL) : Promise<Result<Quote, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_quote", { paragraphId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createPot(pot: Pot) : Promise<Result<null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_pot", { pot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async upsertOutline(outline: Outline, yUpdates: BytesBase64URL[]) : Promise<Result<null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("upsert_outline", { outline, yUpdates }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async upsertParagraph(paragraph: Paragraph, yUpdates: BytesBase64URL[]) : Promise<Result<null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("upsert_paragraph", { paragraph, yUpdates }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createVersion(versionId: UUIDv7Base64URL) : Promise<Result<null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_version", { versionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async insertPendingYUpdate(yDocId: UUIDv7Base64URL, yUpdate: BytesBase64URL) : Promise<Result<null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("insert_pending_y_update", { yDocId, yUpdate }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hardDeleteOutline(outline: Outline) : Promise<Result<null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("hard_delete_outline", { outline }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hardDeleteParagraph(paragraph: Paragraph) : Promise<Result<null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("hard_delete_paragraph", { paragraph }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchPots() : Promise<Result<Pot[], PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_pots") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchTree(id: UUIDv7Base64URL, depth: number | null) : Promise<Result<[Outline[], Paragraph[]], PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_tree", { id, depth }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchTimeline(option: FetchTimelineOption) : Promise<Result<TimelineDay | null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_timeline", { option }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchRelation(outlineIds: UUIDv7Base64URL[], paragraphIds: UUIDv7Base64URL[], option: RelationOption) : Promise<Result<[Outline[], Paragraph[]], PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_relation", { outlineIds, paragraphIds, option }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchRelationCount(outlineIds: UUIDv7Base64URL[], paragraphIds: UUIDv7Base64URL[], countChildren: boolean) : Promise<Result<LinkCount[], PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_relation_count", { outlineIds, paragraphIds, countChildren }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchPath(outlineId: UUIDv7Base64URL) : Promise<Result<Path, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_path", { outlineId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchYUpdatesByDocId(yDocId: UUIDv7Base64URL) : Promise<Result<BytesBase64URL[], PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_y_updates_by_doc_id", { yDocId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchConflictingOutlineIds(outlineId: UUIDv7Base64URL, parentId: UUIDv7Base64URL | null, text: string) : Promise<Result<([UUIDv7Base64URL, string])[], PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_conflicting_outline_ids", { outlineId, parentId, text }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async search(query: string, orderBy: OrderBy, limit: number) : Promise<Result<[Outline[], Paragraph[], SearchResult[]], PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search", { query, orderBy, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAppState() : Promise<Result<AppState, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_state") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateAppState(patch: string) : Promise<Result<null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_app_state", { patch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getWorkspaceState() : Promise<Result<WorkspaceState, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_workspace_state") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateWorkspaceState(patch: string) : Promise<Result<null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_workspace_state", { patch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openPot(potId: UUIDv7Base64URL) : Promise<Result<null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_pot", { potId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openPotSelector() : Promise<Result<null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_pot_selector") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async appVersion() : Promise<string> {
    return await TAURI_INVOKE("app_version");
},
async updatePot(pot: Pot) : Promise<Result<null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_pot", { pot }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deletePot(potId: UUIDv7Base64URL) : Promise<Result<null, PotrinError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_pot", { potId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/


export const events = __makeEvents__<{
appStateChange: AppStateChange,
outlineChange: OutlineChange,
paragraphChange: ParagraphChange,
workspaceStateChange: WorkspaceStateChange
}>({
appStateChange: "app-state-change",
outlineChange: "outline-change",
paragraphChange: "paragraph-change",
workspaceStateChange: "workspace-state-change"
})

/** user-defined constants **/



/** user-defined types **/

export type AppSetting = { search: SearchSetting }
export type AppState = { clientId: UUIDv7Base64URL; user: UserState | null; pots: Partial<{ [key in string]: string }>; setting: AppSetting }
export type AppStateChange = { patch: string }
export type BytesBase64URL = string
export type Direction = "back" | "forward"
export type EditorFocusPosition = number | boolean | PositionString | null
export type FetchTimelineOption = "latest" | { at: number } | { before: number } | { after: number }
export type FocusPosition = { id: string | null; position: EditorFocusPosition }
export type IncludeChildrenOption = { includeParagraphs: boolean }
export type Link = { id: UUIDv7Base64URL; text: string; hidden: boolean }
export type LinkCount = { id: UUIDv7Base64URL; back: number; forward: number }
export type Links = Partial<{ [key in string]: Path }>
export type Operation<T> = { kind: "insert"; targets: Target<T>[] } | { kind: "update"; targets: Target<T>[] } | { kind: "delete"; target_ids: UUIDv7Base64URL[] }
export type Order = "desc" | "asc"
export type OrderBy = { createdAt: Order } | { updatedAt: Order } | "relevance"
export type Origin = "init" | "remote" | { local: { window_label: string } }
export type Outline = { id: UUIDv7Base64URL; parentId: UUIDv7Base64URL | null; fractionalIndex: string; doc: string; text: string; path: Path | null; links: Links; hidden: boolean; collapsed: boolean; deleted: boolean; createdAt: number; updatedAt: number }
export type OutlineChange = { operation: Operation<OutlineForIndex>; origin: Origin }
export type OutlineForIndex = { id: UUIDv7Base64URL; potId: UUIDv7Base64URL; parentId: UUIDv7Base64URL | null; fractionalIndex: string; doc: string; text: string; path: Path; links: Links; hidden: boolean; collapsed: boolean; deleted: boolean; createdAt: number; updatedAt: number }
export type Paragraph = { id: UUIDv7Base64URL; outlineId: UUIDv7Base64URL; fractionalIndex: string; doc: string; quote: Quote | null; links: Links; hidden: boolean; deleted: boolean; createdAt: number; updatedAt: number }
export type ParagraphChange = { operation: Operation<ParagraphForIndex>; origin: Origin }
export type ParagraphForIndex = { id: UUIDv7Base64URL; potId: UUIDv7Base64URL; outlineId: UUIDv7Base64URL; fractionalIndex: string; doc: string; quote: Quote | null; path: Path; links: Links; hidden: boolean; deleted: boolean; createdAt: number; updatedAt: number }
export type Path = Link[]
export type PinnedTabState = { id: string; views: ViewState[]; focusedViewId: string | null; pinnedViewIds: Partial<{ [key in string]: null }> }
export type PositionString = "all" | "start" | "end"
export type Pot = { id: UUIDv7Base64URL; name: string; owner: UUIDv7Base64URL | null; createdAt: number }
export type PotrinError = { anyError: { rootCause: string; msg: string } }
export type Quote = { id: UUIDv7Base64URL; versionId: UUIDv7Base64URL; path: Path; doc: string; latestDoc: string | null }
export type RelationDirection = "back" | "forward"
export type RelationOption = { direction: Direction; includeChildren: IncludeChildrenOption | null }
export type SearchFuzziness = "Exact" | "Fuzzy" | "Fuzziest"
export type SearchResult = { id: UUIDv7Base64URL; doc_type: string }
export type SearchSetting = { fuzziness: SearchFuzziness }
export type SidebarState = { isFloat: boolean; width: number }
export type TabState = { id: string; views: ViewState[]; focusedViewId: string | null }
export type Target<T> = { currentValue: T; relatedYUpdates: BytesBase64URL[] }
export type TimelineDay = { dayStart: number; paragraphs: Paragraph[]; outlines: Outline[] }
export type UUIDv7Base64URL = string
export type UserState = { id: UUIDv7Base64URL; name: string }
export type ViewState = { type: "cards"; id: string; outlineId: UUIDv7Base64URL | null; title: string; flexGrow: number; scrollPosition: number; focusPosition: FocusPosition } | { type: "outline"; id: string; outlineId: UUIDv7Base64URL | null; title: string; flexGrow: number; scrollPosition: number; focusPosition: FocusPosition } | { type: "document"; id: string; outlineId: UUIDv7Base64URL | null; title: string; flexGrow: number; scrollPosition: number; focusPosition: FocusPosition } | { type: "timeline"; id: string; flexGrow: number } | { type: "relation"; id: string; outlineId: UUIDv7Base64URL; title: string; direction: RelationDirection; flexGrow: number; scrollPosition: number } | { type: "search"; id: string; query: string; scope: UUIDv7Base64URL | null; flexGrow: number; scrollPosition: number }
export type WorkspaceState = { pot: Pot; pinnedTabs: PinnedTabState[]; tabs: TabState[]; focusedTabId: string | null; sidebar: SidebarState }
export type WorkspaceStateChange = { patch: string }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
